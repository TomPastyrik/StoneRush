/** 
 * This file is part of semestral assigment
 * STONE RUSH GAME for A0M33KAJ course
 * at CTU FEE, 2014
 * 
 * @author Tom Pastýřík <mail@tomaspastyrik.cz>
 */


/**
 * Handles Game loop, initializes and updates
 * canvas using easeljs library.
 * 
 * @param {Hero} _hero
 * @returns {HeroAnimator}
 */
var HeroAnimator = function(_hero) {

    this.hero = _hero;

    this.canvas;
    this.stage;
    this.canvas_width;
    this.canvas_height;
    this.bmpAnimation;
    this.bmpAnimationIdle;

    this.numberOfImagesLoaded = 0;

    this.imgMonsterARun = new Image();
    this.imgMonsterAIdle = new Image();
};



HeroAnimator.prototype.init = function() {
    //find canvas and load images, wait for last image to load

    this.canvas = document.createElement("canvas");
    $('#gameGrid').prepend(this.canvas);
    this.imgMonsterARun.onload = this.handleImageLoad.bind(this);
    this.imgMonsterARun.onerror = this.handleImageError.bind(this);
    this.imgMonsterARun.src = "./img/yoda.png";

    this.imgMonsterAIdle.onload = this.handleImageLoad.bind(this);
    this.imgMonsterAIdle.onerror = this.handleImageError.bind(this);
    this.imgMonsterAIdle.src = "./img/yoda.png";
};

HeroAnimator.prototype.handleImageLoad = function(e) {
    this.numberOfImagesLoaded++;

    if (this.numberOfImagesLoaded === 1) { // This is walk image

	this.canvas_width = this.imgMonsterARun.width / 4;
	this.canvas_height = this.imgMonsterARun.height / 4;
	this.canvas.width = this.canvas_width;
	this.canvas.height = this.canvas_height;
    }

    // We're not starting the game until all images are loaded
    // Otherwise, you may start to draw without the resource and raise
    // this DOM Exception: INVALID_STATE_ERR (11) on the drawImage method
    if (this.numberOfImagesLoaded === 2) {
	this.numberOfImagesLoaded = 0;
	this.startGame();
    }
};

HeroAnimator.prototype.reset = function() {
    this.stage.removeAllChildren();
    createjs.Ticker.removeAllListeners();
    this.stage.update();
};

HeroAnimator.prototype.startGame = function() {
    // create a new stage and point it at our canvas:
    this.stage = new createjs.Stage(this.canvas);

    // grab canvas width and height for later calculations:
    screen_width = this.canvas.width;
    screen_height = this.canvas.height;

    // create spritesheet and assign the associated data.
    var spriteSheet = new createjs.SpriteSheet({
	//image to use
	images: [this.imgMonsterARun],
	//width, height & registration point of each sprite
	frames: {width: this.canvas_width, height: this.canvas_height, regX: this.canvas_width / 2, regY: this.canvas_height - this.canvas_height / 3},
	// To slow down the animation loop of the sprite, we set the frequency to 4 to slow down by a 4x factor
	animations: {
	    walkDown: [0, 3, "walkDown", 2],
	    walkUp: [12, 15, "walkUp", 2],
	    walkLeft: [4, 7, "walkLeft", 2],
	    walkRight: [8, 11, "walkRight", 2]
	}
    });

    // Idle sequence of the monster
    var spriteSheetIdle = new createjs.SpriteSheet({
	images: [this.imgMonsterAIdle],
	frames: {width: this.canvas_width, height: this.canvas_height, regX: this.canvas_width / 2, regY: this.canvas_height - this.canvas_height / 3},
	animations: {
	    idle: [0, 2, "idle", 64]
	}
    });

    this.bmpAnimationIdle = new createjs.BitmapAnimation(spriteSheetIdle);

    this.bmpAnimationIdle.name = "monsteridle1";
    this.bmpAnimationIdle.x = 16;
    this.bmpAnimationIdle.y = 32;

    // create a BitmapSequence instance to display and play back the sprite sheet:
    this.bmpAnimation = new createjs.BitmapAnimation(spriteSheet);

    // set the registration point (the point it will be positioned and rotated around)
    // to the center of the frame dimensions:
    this.bmpAnimation.regX = this.bmpAnimation.spriteSheet.frameWidth / 2 | 0;
    this.bmpAnimation.regY = this.bmpAnimation.spriteSheet.frameHeight / 2 | 0;

    // start playing the first sequence:
    // walk_h has been generated by addFlippedFrames and
    // contained the right facing animations
    this.bmpAnimation.gotoAndPlay("idle"); 	//walking from left to right

    // set up a shadow. Note that shadows are ridiculously expensive. You could display hundreds
    // of animated rats if you disabled the shadow.
    //this.bmpAnimation.shadow = new createjs.Shadow("#454", 0, 5, 4);

    this.bmpAnimation.name = "monster1";
    this.bmpAnimation.direction = 90;
    this.bmpAnimation.vX = 0;
    this.bmpAnimation.vY = 0;
    this.bmpAnimation.x = 16;
    this.bmpAnimation.y = 32;

    // have each monster start at a specific frame
    this.bmpAnimation.currentFrame = 10;
    this.stage.addChild(this.bmpAnimation);

    // we want to do some work before we update the canvas,
    // otherwise we could use Ticker.addListener(stage);
    createjs.Ticker.addListener(window);
    createjs.Ticker.useRAF = true;
    // Best Framerate targeted (60 FPS)
    createjs.Ticker.setFPS(60);
};

//called if there is an error loading the image (usually due to a 404)
HeroAnimator.prototype.handleImageError = function(e) {
    console.log("Error Loading Image : " + e.target.src);
};

IDLE = true;

function tick() {

    kd.tick();

    if (!IDLE && MyHero.noDirFollows && !MyHero.justStopped && !MyHero.isWalking) {
	MyHero.justStopped = true;
    }
    
    
    if(!MyHero.gameplay.canWalkToStone(MyHero.coords[0], MyHero.coords[1])){
	MyHero.gameplay.gameOver("LOOSE");
    }

    if (MyHero.justStarted) {
	animator.bmpAnimationIdle.gotoAndStop("idle");
	animator.stage.removeChild(animator.bmpAnimationIdle);
	if (MyHero.toBeWalkedUP > 0) {
	    animator.bmpAnimation.gotoAndPlay("walkUp");
	}
	
	if (MyHero.toBeWalkedDOWN > 0){
	    animator.bmpAnimation.gotoAndPlay("walkDown");
	}

	if (MyHero.toBeWalkedLEFT > 0){
	    animator.bmpAnimation.gotoAndPlay("walkLeft");
	}

	if (MyHero.toBeWalkedRIGHT > 0){
	    animator.bmpAnimation.gotoAndPlay("walkRight");
	}

	animator.stage.addChild(animator.bmpAnimation);
	MyHero.justStarted = false;
	IDLE = false;
    }

    if (MyHero.noDirFollows && MyHero.justStopped) {
	animator.bmpAnimation.gotoAndStop("walk");
	animator.stage.removeChild(animator.bmpAnimation);
	animator.bmpAnimationIdle.gotoAndPlay("idle");
	animator.stage.addChild(animator.bmpAnimationIdle);
	MyHero.justStopped = false;
	IDLE = true;
    }



    if (MyHero.isWalking) {
	if (MyHero.toBeWalkedUP > 0) {
	    MyHero.justStarted = false;
	    GameGrid.topPos += 8;
//            GameGrid.leftPos -= 4;
	    gameGridElement.style.marginTop = GameGrid.topPos + 'px';
	    gameGridElement.style.marginLeft = GameGrid.leftPos + 'px';
	    MyHero.toBeWalkedUP -= 8;
	    if (MyHero.toBeWalkedUP === 0) {
		MyHero.resetWalking();
		MyHero.isWalking = false;
		MyHero.justStopped = true;
//                GameGrid.leftPos -= 3;
		gameGridElement.style.marginLeft = GameGrid.leftPos + 'px';
	    }
	} else if (MyHero.toBeWalkedDOWN > 0) {
	    MyHero.justStarted = false;
	    GameGrid.topPos -= 8;
//            GameGrid.leftPos += 4;
	    gameGridElement.style.marginTop = GameGrid.topPos + 'px';
	    gameGridElement.style.marginLeft = GameGrid.leftPos + 'px';
	    MyHero.toBeWalkedDOWN -= 8;
	    if (MyHero.toBeWalkedDOWN === 0) {
		MyHero.isWalking = false;
		MyHero.justStopped = true;
		MyHero.resetWalking();
//                GameGrid.leftPos += 3;
		gameGridElement.style.marginLeft = GameGrid.leftPos + 'px';
	    }
	} else if (MyHero.toBeWalkedRIGHT > 0) {
	    MyHero.justStarted = false;
	    GameGrid.leftPos -= 8;
	    gameGridElement.style.marginLeft = GameGrid.leftPos + 'px';
	    MyHero.toBeWalkedRIGHT -= 8;
	    if (MyHero.toBeWalkedRIGHT <= 0) {
		MyHero.justStopped = true;
		MyHero.isWalking = false;
		GameGrid.leftPos += 4;
		gameGridElement.style.marginLeft = GameGrid.leftPos + 'px';
		MyHero.resetWalking();
	    }
	} else if (MyHero.toBeWalkedLEFT > 0) {
	    MyHero.justStarted = false;
	    GameGrid.leftPos += 8;
	    gameGridElement.style.marginLeft = GameGrid.leftPos + 'px';
	    MyHero.toBeWalkedLEFT -= 8;
	    if (MyHero.toBeWalkedLEFT <= 0) {
		MyHero.justStopped = true;
		MyHero.isWalking = false;
		GameGrid.leftPos -= 4;
		gameGridElement.style.marginLeft = GameGrid.leftPos + 'px';
		MyHero.resetWalking();
	    }
	}
    }
    // update the stage:
    animator.stage.update();
}
;
